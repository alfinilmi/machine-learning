# -*- coding: utf-8 -*-
"""simple-sistem-rekomendasi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gPIk70I0pTJRe2FqZK_K7jaRSnHlbcsT

# Sistem Rekomendasi Netflix

ID : M299X0762

Nama : Alfin Muhammad Ilmi

Dataset: **Netflix Movies and TV Shows** *accessed from* https://www.kaggle.com/datasets/shivamb/netflix-shows

## Import Libraries
"""

!pip install opendatasets

import opendatasets as od
import pandas as pd
import numpy as np
import time

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics.pairwise import euclidean_distances

"""## Download Dataset"""

od.download("https://www.kaggle.com/datasets/shivamb/netflix-shows")

"""## Univariate Exploratory Data Analysis"""

df = pd.read_csv("/content/netflix-shows/netflix_titles.csv")
print("Shape:", df.shape)
df.head()

"""*Output* kode di atas memberikan informasi sebagai berikut:

* Ada 8807 baris (*records* atau jumlah pengamatan) dalam dataset.
* Terdapat 12 kolom (fitur) yaitu `show_id`, `type`, `title`, `director`, `cast`, `country`, `date_added`, `release_year`, `rating`, `duration`, `listed_in`, `description`.

### Deskripsi Variabel

Sesuai dengan informasi dari [Kaggle](https://www.kaggle.com/datasets/shivamb/netflix-shows), Variabel-variabel pada *Netflix Movies and TV Shows* Dataset adalah sebagai berikut:

* `show_id` adalah ID untuk setiap *Movie* / *TV Show*
* `type` adalah sebagai pengenal apakah termasuk pada kategori *Movie* / *TV Show*
* `title` adalah judul dari *Movie* / *TV Show*
* `director` adalah nama dari sutradara film (*Movie*)
* `cast` adalah aktor yang terlibat dalam *Movie* / *TV Show*
* `country` adalah negara tempat *Movie* / *TV Show* itu diproduksi
* `date_added` adalah tanggal *Movie* / *TV Show* ditambahkan ke Netflix
* `release_year` adalah tahun rilis sebenarnya dari *Movie* / *TV Show*
* `rating` adalah jenis-jenis rating *Movie* / *TV Show*
* `duration` adalah durasi total (dalam menit atau jumlah *season*)
* `listed_in` adalah genre atau aliran *Movie* / *TV Show*
* `description` adalah deskripsi ringkasan

## Data Preprocessing

### Menentukan fitur yang akan digunakan

Dalam kasus ini, kita akan merekomendasikan film berdasarkan genre saja. Sehingga kita hanya membutuhkan kolom (fitur) `show_id`, `title`, dan `listed_in`. 

Selain itu kita hanya memilih data yang bertipe `Movie`. Sehingga data yang bertipe `TV Show` tidak dibutuhkan.
"""

df = df.loc[df["type"] == "Movie"]

df_movies = df[["show_id", "title", "listed_in"]]
df_movies.head()

"""## Data Preparation

### Mengatasi Missing Value
"""

df_movies.isnull().sum()

df_movies.isna().sum()

"""Dari output di atas, terlihat bahwa tidak ada *missing value* pada dataset.

### Menghilangkan data duplikat pada judul film

Sebelum menghilangkan data duplikat, kita cek terlebih dahulu apakah ada data yang duplikat atau tidak
"""

pd.DataFrame({"Unique title": df_movies['title'].nunique(),
              "Total Data": len(df_movies['title'])}, index=["Jumlah Film"])

"""Dapat dilihat bahwa jumlah `title` yang berbeda sama dengan total data. Ini menunjukkan bahwa setiap baris memiliki judul film yang berbeda-beda.

## Model Development dengan Content Based Filtering

Di tahap ini, sistem rekomendasi dibuat menggunakan model dengan metode *Cosine Similarity* dan *Euclidean Similarity*. Tetapi sebelumnya akan dilakukan perubahan tipe data dari kategorikal menjadi data numerik menggunakan metode `TF-IDF Vectorizer`.

### TF-IDF Vectorizer
"""

tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data nikes
tf.fit(df_movies['listed_in']) 
 
# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(df_movies['listed_in']) 

tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(), 
    columns=tf.get_feature_names(),
    index=df_movies.title
).sample(10, axis=1).sample(10, axis=0)

"""### Cosine Similarity

Kelebihan dari metode *cosine similarity* adalah tidak bergantung pada besarnya vektor. Tetapi kelebihan tersebut dapat menjadi kekurangan jika pada kasus tertentu, makna frekuensi kemunculan fitur menjadi penting. Sedangkan pada kasus ini, *Cosine Similarity* aman digunakan karena sudah dilakukan tahap *one-hot-encoding* pada matrik tf-idf. Sehingga frekuensi tiap kategori pada produk mempunyai bobot yang sama yaitu 0 (tidak ada) atau 1 (ada).

Untuk implementasinya menggunakan fungsi `cosine_similarity()` dari *library* sklearn dengan lama waktu komputasinya sebagai berikut.
"""

def cos_sim_handler(df_tfidf, series_title):
  # Menghitung cosine similarity pada dataframe tfidf
  cos_sim = cosine_similarity(df_tfidf)

  # Membuat dataframe dari variabel cos_sim dengan baris dan kolom berupa nama produk
  df_cos_sim = pd.DataFrame(cos_sim, index=series_title, columns=series_title)

  # Melihat similarity matrix pada setiap produk
  return df_cos_sim

start = time.time()
cos_sim_df = cos_sim_handler(tfidf_matrix, df_movies['title'])
cos_exec_time = time.time() - start
print("Exec Time Cosine Similarity (Seconds) :", cos_exec_time)

# Melihat similarity matrix pada setiap produk
print('Shape:', cos_sim_df.shape)
cos_sim_df.sample(5, axis=1).sample(10, axis=0)

"""### Euclidean Distance

Kelebihan Euclidean adalah dapat memperoleh nilai perbedaan antara dua vektor yang sama arahnya namun beda besarannya. Sedangkan kekurangan algoritma ini adalah fitur dengan frekuensi kemunculan paling banyak akan mendominasi fitur lain dalam hasil komputasi jarak euclideannya.

Untuk implementasinya menggunakan fungsi `euclidean_distances()` dari *library* sklearn dengan lama waktu komputasinya sebagai berikut.
"""

def euc_sim_handler(df_tfidf, series_title):
  # Menghitung euclidean distance pada dataframe tfidf
  euc_dist = euclidean_distances(df_tfidf)

  # Menghitung euclidean similarity
  f = lambda x: 1 / (1 + x)
  euc_sim = f(euc_dist)

  # Membuat dataframe dari variabel euc_sim dengan baris dan kolom berupa nama produk
  df_euc_sim = pd.DataFrame(euc_sim, index=series_title, columns=series_title)

  # Melihat similarity matrix pada setiap produk
  return df_euc_sim

start = time.time()
euc_sim_df = euc_sim_handler(tfidf_matrix, df_movies["title"])
euc_exec_time = time.time() - start
print("Exec Time Euclidean Similarity (Seconds) :", euc_exec_time)

print('Shape:', euc_sim_df.shape)
euc_sim_df.sample(5, axis=1).sample(10, axis=0)

"""### Mendapatkan Rekomendasi

Tahap ini merupakan tahap pengujian hasil top-10 rekomendasi judul film.
"""

def movie_recommendations(judul_film, similarity_data, items=df_movies, k=10):
 
    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan    
    # Dataframe diubah menjadi numpy
    index = similarity_data.loc[:,judul_film].to_numpy().argpartition(
        range(-1, -k, -1))
    
    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    
    closest = closest.drop(judul_film, errors='ignore')
 
    return pd.DataFrame(closest).merge(items).head(k)

df_movies[df_movies["title"].eq('Bo Burnham: Inside')]

"""#### Rekomendasi dengan Cosine Similarity"""

movie_recommendations(
    judul_film="Bo Burnham: Inside",
    similarity_data=cos_sim_df
)

"""#### Rekomendasi dengan Euclidean Distance"""

movie_recommendations(
    judul_film="Bo Burnham: Inside",
    similarity_data=euc_sim_df
)

"""## Evaluasi

$$\text{Recommender system precision (P)} = \frac{\text{#of our recommendation that relevant}}{\text{#of item we recommend}}\times 100% $$

Dari hasil rekomendasi di atas diketahui bahwa film dengan judul `Bo Burnham: Inside` termasuk ke dalam genre atau aliran `Stand-Up Comedy`. Dari 10 produk yang direkomendasikan, berikut nilai *precision* pada model *cosine similarity* dan *euclidean distance*.
 
|Model | Sesuai | Tidak Sesuai |Total| Precision |
|---|---|---|---|---|
|*Cosine Similarity*|10|0|10|100%|
|*Euclidean Similarity*|10|0|10|100%|
 
Pada tabel di atas, terlihat bahwa model *Cosine Similiarity* dan *Euclidean Distance* memiliki nilai presisi yang sama pada top-10 rekomendasi di atas.

Selain dari nilai presisi, lama komputasi setiap metode juga perlu dipertimbangkan. Berikut perbandingannya:
"""

df_exec_time_models = pd.DataFrame(index=['Time (Seconds)'],
    columns=['Cosine Similarity', 'Euclidean Similarity'])

df_exec_time_models['Cosine Similarity'] = [cos_exec_time]
df_exec_time_models['Euclidean Similarity'] = [euc_exec_time]

df_exec_time_models

"""Berdasarkan output di atas, waktu komputasi pada metode Cosine Similarity (1.004601 detik) lebih cepat dibandingkan Euclidean Similarity (2.640574 detik)."""